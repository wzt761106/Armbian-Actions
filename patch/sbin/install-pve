#!/bin/bash
# =============================================================================
#  脚本名称：install-pve
#  适用架构：ARM64 (aarch64/arm64)
#  脚本功能：Armbian ARM64 系统安装 Pxvirt (Proxmox VE)
#  适用系统：Debian 12 (bookworm) → Pxvirt 8 | Debian 13 (trixie) → Pxvirt 9
#  功能说明：配置国内源、添加 Pxvirt 源并安装、内存占用优化、配置网桥及配置 IPV6 参数
#  教程链接：https://zhou.pp.ua
# =============================================================================
set -e

# ========== 字体颜色 ==========
STEPS="[\033[95m 步骤 \033[0m]"
INFO="[\033[94m 信息 \033[0m]"
SUCCESS="[\033[92m 成功 \033[0m]"
OPTIONS="[\033[93m 选项 \033[0m]"
ERROR="[\033[91m 错误 \033[0m]"
SN="[\033[96m 序号 \033[0m]"

# ========== 错误处理 ==========
error() {
    echo -e "${ERROR} ${1}"
    exit 1
}

# ========== 检查环境 ==========
check_env() {
  if [[ "$(id -u)" -ne 0 ]]; then
    error "请使用 root 用户运行！"
  fi
  source /etc/os-release
  if [[ ! "${VERSION_CODENAME}" =~ ^(bookworm|trixie)$ ]]; then
    error "当前系统 [\033[91m ${VERSION_CODENAME} \033[0m] 不支持！"
  fi
  ARCH=$(uname -m)
  if [[ ! "${ARCH}" =~ ^(aarch64|arm64)$ ]]; then
    error "当前架构 [\033[91m ${ARCH} \033[0m] 非 ARM64 架构！"
  fi
}

# ========== 函数定义 ==========
check_select_interface() {
  NET_IF_LIST=$(ip route | awk '/^default/ {for(i=1;i<=NF;i++) if($i=="dev") print $(i+1)}' | sort -u)
  [[ -z "${NET_IF_LIST}" ]] && error "未找到默认网络接口，请检查网络配置！"
  # 初始化数组
  VALID_IF_LIST=()
  VALID_INDEX=()
  # 判断是否为桥接接口
  is_bridge_or_member() {
      ip -d link show "$1" | grep -Eq "bridge|brport"
  }
  # 判断是否为无线接口
  is_wireless() {
    [[ -d "/sys/class/net/$1/wireless" ]] || [[ -e "/proc/net/wireless" && $(awk '/'"$1"':/ {print $1}' /proc/net/wireless) ]]
  }
  # 多默认接口
  if [[ $(echo "${NET_IF_LIST}" | wc -l) -gt 1 ]]; then
    echo -e "${OPTIONS} 检测到多个默认网络接口，请选择："
    i=1
    for iface in ${NET_IF_LIST}; do
      ip_addr=$(ip -4 addr show "${iface}" | awk '/inet /{print $2}' | cut -d/ -f1 | head -n1)
      if is_bridge_or_member "${iface}"; then
        mark="[\033[91m x \033[0m]"
        color="\033[91m"
        comment="[ 桥接接口，禁止使用 ]"
        selectable="no"
      elif is_wireless "${iface}"; then
        mark="[\033[91m x \033[0m]"
        color="\033[91m"
        comment="[ 无线接口，禁止使用 ]"
        selectable="no"
      else
        mark="[\033[92m ✓ \033[0m]"
        color="\033[92m"
        comment=""
        selectable="yes"
      fi
      echo -e "${SN} [\033[96m ${i} \033[0m] -> [${color} ${iface} - ${ip_addr:-无 IP} \033[0m] ${mark} ${comment}"
      # 只记录可用的接口编号和名称
      if [[ "${selectable}" == "yes" ]]; then
        VALID_IF_LIST+=("${iface}")
        VALID_INDEX+=("${i}")
      fi
      i=$((i+1))
    done
    # 若无可用接口
    if [[ ${#VALID_IF_LIST[@]} -eq 0 ]]; then
      error "所有默认网络接口均不可用，请调整后重试！"
    fi
    # 选择接口
    while true; do
      read -p "$(echo -e "${OPTIONS} 请输入序号：")" SN_CHOICE
      SN_CHOICE=${SN_CHOICE:-1}

      for idx in "${!VALID_INDEX[@]}"; do
        if [[ "${SN_CHOICE}" == "${VALID_INDEX[$idx]}" ]]; then
          NET_IF="${VALID_IF_LIST[$idx]}"
          break 2
        fi
      done
      echo -e "${ERROR} 输入无效或该接口不可使用，请重新输入！"
    done
  else
    # 单默认接口
    NET_IF="${NET_IF_LIST}"
    ip_addr=$(ip -4 addr show "${NET_IF}" | awk '/inet /{print $2}' | cut -d/ -f1 | head -n1)
    if is_bridge_or_member "${NET_IF}"; then
      error "默认网络接口 [\033[91m ${NET_IF} - ${ip_addr:-无 IP} \033[0m] 属于桥接接口，请调整后重试！"
    fi
    if is_wireless "${NET_IF}"; then
      error "默认网络接口 [\033[91m ${NET_IF} - ${ip_addr:-无 IP} \033[0m] 属于无线接口，请使用有线接口！"
    fi
    echo -e "${INFO} 检测到默认网络接口：[\033[92m ${NET_IF} - ${ip_addr:-无 IP} \033[0m]"
  fi
}

detect_network_info() {
  [[ -z "${NET_IF}" ]] && error "未检测到有效的网络接口！"
  ADDR_INFO=$(ip -4 addr show "${NET_IF}" | awk '/inet / {print $2; exit}')
  IP_ADDR=${ADDR_INFO%/*}
  CIDR=${ADDR_INFO#*/}
  GATEWAY=$(ip route | awk -v iface="${NET_IF}" '$1=="default" && $0~("dev "iface) {print $3; exit}')
  MAC_ADDR=$(cat "/sys/class/net/${NET_IF}/address" 2>/dev/null)
  [[ -n "${CIDR}" ]] && NETMASK=$(cidr_to_netmask "${CIDR}")
  if [[ -z "${IP_ADDR}" || -z "${GATEWAY}" || -z "${CIDR}" || -z "${NETMASK}" ]]; then
    error "获取网络信息失败，请检查接口 ${NET_IF} 是否配置 IPv4！"
  fi
  echo -e "${INFO} 接口：\033[95m${NET_IF}\033[0m"
  echo -e "${INFO} IPv4：\033[95m${IP_ADDR}\033[0m"
  echo -e "${INFO} 网关：\033[95m${GATEWAY}\033[0m"
  echo -e "${INFO} 掩码：\033[95m${NETMASK}\033[0m"
  echo -e "${INFO} MAC ：\033[95m${MAC_ADDR}\033[0m"
}

cidr_to_netmask() {
  local cidr=${1}
  if [[ -z "${cidr}" || "${cidr}" -le 0 || "${cidr}" -gt 32 ]]; then
    error "子网掩码位数无效！"
  fi
  local i mask=""
  local full_octets=$((cidr / 8))
  local remainder=$((cidr % 8))
  for ((i = 0; i < 4; i++)); do
    if ((i < full_octets)); then
      mask+=255
    elif ((i == full_octets)); then
      mask+=$((256 - 2**(8 - remainder)))
    else
      mask+=0
    fi
    [[ ${i} -lt 3 ]] && mask+=.
  done
  echo "${mask}"
}

confirm_source() {
  echo -e "${INFO} 请确认系统已更换为国内镜像软件源！"
  echo -e "${INFO} 网络环境可以稳定访问官方源，可忽略！"
  echo -e "${INFO} 图文教程参考：[\033[92m https://zhou.pp.ua \033[0m]"
  read -p "$(echo -e "${OPTIONS} 是否已更换为国内源？[y/\033[92mN\033[0m]：")" USE_DOMESTIC_SOURCE_CHOICE
  USE_DOMESTIC_SOURCE_CHOICE=${USE_DOMESTIC_SOURCE_CHOICE:-N}
  if [[ "${USE_DOMESTIC_SOURCE_CHOICE}" =~ ^[Nn]$ ]]; then
    SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
    if [[ -x "${SCRIPT_DIR}/armbian-apt" ]]; then
      echo -e "${STEPS} 正在调用本地 [\033[92m armbian-apt \033[0m] 选择国内源！"
      "${SCRIPT_DIR}/armbian-apt"
    elif command -v armbian-apt >/dev/null 2>&1; then
      echo -e "${STEPS} 正在调用系统 [\033[92m armbian-apt \033[0m] 选择国内源！"
      armbian-apt
    else
      error "未找到 [\033[92m armbian-apt \033[0m]，请手动更换国内源！"
    fi
    read -p "$(echo -e "${OPTIONS} 是否进行安装？[\033[92mY\033[0m/n]：")" CONTINUE_INSTALL_CHOICE
    CONTINUE_INSTALL_CHOICE=${CONTINUE_INSTALL_CHOICE:-Y}
    if [[ ! "${CONTINUE_INSTALL_CHOICE}" =~ ^[Yy]$ ]]; then
      echo -e "${INFO} 中止安装，已退出！"
      exit 0
    fi
  fi
}

backup_and_comment_sources() {
  echo -e "${INFO} 开始配置环境..."
  for FILE in /etc/apt/sources.list.d/armbian.sources /etc/apt/sources.list.d/armbian-config.sources /etc/apt/sources.list.d/armbian.list; do
    BAK="${FILE}.bak"
    if [ -f "${FILE}" ] && [ ! -f "${BAK}" ]; then
      cp "${FILE}" "${BAK}"
      echo -e "${STEPS} 已备份：\033[95m${BAK}\033[0m"
    fi
    if [ -f "${FILE}" ]; then
      sed -i 's/^\([^#]\)/#\1/' "${FILE}"
      echo -e "${STEPS} 已注释：\033[95m${FILE}\033[0m"
    fi
  done
  if [ -f /etc/apt/sources.list ]; then
    FILE=/etc/apt/sources.list.d/debian.sources
    BAK="${FILE}.bak"
    if [ -f "${FILE}" ] && [ ! -f "${BAK}" ]; then
      cp "${FILE}" "${BAK}"
      echo -e "${STEPS} 已备份：\033[95m${BAK}\033[0m"
    fi
    if [ -f "${FILE}" ]; then
      sed -i 's/^\([^#]\)/#\1/' "${FILE}"
      echo -e "${STEPS} 已注释：\033[95m${FILE}\033[0m"
    fi
  fi
}

setup_repositories() {
  export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin
  COUNTRY=$(curl -fsS --max-time 3 https://ipinfo.io/country 2>/dev/null || echo "UNKNOWN")
  COUNTRY=${COUNTRY:-UNKNOWN}
  declare -A MIRRORS
  MIRRORS[CN]="https://download.lierfang.com"
  MIRRORS[JP]="https://jp.mirrors.lierfang.com"
  MIRRORS[DE]="https://de.mirrors.lierfang.com"
  MIRRORS[DEFAULT]="https://mirrors.apqa.cn"
  case "${COUNTRY}" in
    CN) PRIMARY="${MIRRORS[CN]}"; REGION="China" ;;
    JP) PRIMARY="${MIRRORS[JP]}"; REGION="Japan" ;;
    DE) PRIMARY="${MIRRORS[DE]}"; REGION="Germany" ;;
    UNKNOWN|*) PRIMARY="${MIRRORS[DEFAULT]}"; REGION="Cloudflare" ;;
  esac
  echo -e "${INFO} 检测到地区：\033[95m${COUNTRY}\033[0m → 首选源：\033[95m${REGION} (${PRIMARY})\033[0m"
  MIRROR=""
  if curl -fsIL --retry 2 --retry-delay 1 --max-time 5 "${PRIMARY}/pxcloud/" >/dev/null 2>&1; then
    MIRROR="${PRIMARY}"
    echo -e "${INFO} 首选源可用 → 使用：\033[95m${REGION} (${MIRROR})\033[0m"
  else
    echo -e "${INFO} 首选源不可用：\033[95m${PRIMARY}\033[0m"
    if [[ "${PRIMARY}" != "${MIRRORS[DEFAULT]}" ]]; then
      echo -e "${INFO} 尝试 \033[95mCloudflare\033[0m 源..."
      if curl -fsI -m 3 "${MIRRORS[DEFAULT]}/pxcloud/" >/dev/null 2>&1; then
        MIRROR="${MIRRORS[DEFAULT]}"
        REGION="Cloudflare"
        echo -e "${INFO} \033[95mCloudflare\033[0m 源可用 → 使用：\033[95m${REGION} (${MIRROR})\033[0m"
      else
        echo -e "${INFO} \033[95mCloudflare\033[0m 源不可用：\033[95m${MIRRORS[DEFAULT]}\033[0m"
      fi
    fi
    if [[ -z "${MIRROR}" ]]; then
      echo -e "${INFO} 尝试备用源..."
      for SRC in "${MIRRORS[CN]}" "${MIRRORS[JP]}" "${MIRRORS[DE]}"; do
        [[ "${SRC}" == "${PRIMARY}" ]] && continue
        if curl -fsI -m 3 "${SRC}/pxcloud/" >/dev/null 2>&1; then
          MIRROR="${SRC}"
          case "${SRC}" in
            "${MIRRORS[CN]}") REGION="China" ;;
            "${MIRRORS[JP]}") REGION="Japan" ;;
            "${MIRRORS[DE]}") REGION="Germany" ;;
          esac
          echo -e "${INFO} 找到可用备用源 → 使用：\033[95m${REGION} (${MIRROR})\033[0m"
          break
        else
          echo -e "${INFO} 备用源不可用：\033[95m${SRC}\033[0m"
        fi
      done
    fi
  fi
  [[ -z "${MIRROR}" ]] && error "所有软件源均不可用，请检查网络！"
  if curl -fsSL "${MIRROR}/pxcloud/lierfang.gpg" -o /etc/apt/trusted.gpg.d/lierfang.gpg >/dev/null 2>&1; then
    echo -e "${STEPS} 已下载：\033[95m/etc/apt/trusted.gpg.d/lierfang.gpg\033[0m"
  else
    error "下载 lierfang.gpg 失败！"
  fi
  if echo "deb ${MIRROR}/pxcloud/pxvirt ${VERSION_CODENAME} main" > /etc/apt/sources.list.d/pxvirt-sources.list; then
    echo -e "${STEPS} 已写入：\033[95m/etc/apt/sources.list.d/pxvirt-sources.list\033[0m"
  else
    error "写入 pxvirt-sources.list 失败！"
  fi
}

setup_networking() {
  apt update && apt install -y ifupdown2 resolvconf
  systemctl enable networking
  systemctl disable systemd-networkd systemd-networkd.socket 2>/dev/null || true
  apt remove -y netplan.io && apt autoremove -y
  systemctl disable --now NetworkManager 2>/dev/null || true
}

set_hostname() {
  local CURRENT_HOSTNAME NEW_HOSTNAME_CHOICE
  CURRENT_HOSTNAME=$(tr -d ' \t\n\r' < /etc/hostname)
  read -p "$(echo -e "${OPTIONS} 自定义主机名（回车跳过）：")" NEW_HOSTNAME_CHOICE
  if [[ -n "${NEW_HOSTNAME_CHOICE}" ]]; then
    hostnamectl set-hostname "${NEW_HOSTNAME_CHOICE}"
    echo -e "${SUCCESS} 主机名已更改为：[\e[1;32m ${NEW_HOSTNAME_CHOICE} \e[0m]"
  else
    echo -e "${INFO} 保持当前主机名：[\e[1;32m ${CURRENT_HOSTNAME} \e[0m]"
  fi
}

configure_network() {
  NETMASK_DECIMAL=$(cidr_to_netmask "${CIDR}")
  echo -e "${STEPS} 配置 \033[95m/etc/network/interfaces\033[0m"
  cat <<EOF > /etc/network/interfaces
auto lo
iface lo inet loopback

auto ${NET_IF}
iface ${NET_IF} inet static
    hwaddress ether ${MAC_ADDR}
    address ${IP_ADDR}
    netmask ${NETMASK_DECIMAL}
    gateway ${GATEWAY}
EOF

  echo -e "${STEPS} 配置 \033[95m/etc/resolv.conf\033[0m"
  cat <<EOF > /etc/resolv.conf
search lan
nameserver ${GATEWAY}
EOF
  CURRENT_HOSTNAME=$(tr -d ' \t\n\r' < /etc/hostname)
  echo -e "${STEPS} 配置 \033[95m/etc/hosts\033[0m"
  cat <<EOF > /etc/hosts
127.0.0.1       localhost
${IP_ADDR}   ${CURRENT_HOSTNAME}.local ${CURRENT_HOSTNAME}
::1             localhost ip6-localhost ip6-loopback
fe00::0         ip6-localnet
ff00::0         ip6-mcastprefix
ff02::1         ip6-allnodes
ff02::2         ip6-allrouters
EOF
}

install_pve() {
  echo -e "${INFO} 安装 Pxvirt $([ "${VERSION_CODENAME}" = "bookworm" ] && echo 8 || echo 9)..."
  if apt update && apt install -y proxmox-ve; then
    if [[ -f "/etc/ophub-release" ]]; then
      echo -e "${INFO} 正在更新证书..."
      rm -f /etc/pve/pve-root-ca.pem /etc/pve/priv/pve-root-ca.* /etc/pve/local/pve-ssl.*
      pvecm updatecerts -f >/dev/null 2>&1 || true
      systemctl restart pveproxy >/dev/null 2>&1 || {
        error "无法重启 pveproxy 服务，请检查！"
      }
      echo -e "${SUCCESS} 证书更新成功！"
    fi
    echo -e "${SUCCESS} Pxvirt $([ "${VERSION_CODENAME}" = "bookworm" ] && echo 8 || echo 9) 安装成功！请重启设备后浏览器访问：[\033[92m https://${IP_ADDR}:8006 \033[0m]"
  else
    error "Pxvirt $([ "${VERSION_CODENAME}" = "bookworm" ] && echo 8 || echo 9) 安装失败，请检查源和网络！"
  fi
}

optimize_memory() {
  read -p "$(echo -e "${OPTIONS} 是否进行内存优化？[\033[92mY\033[0m/n]：")" OPTIMIZE_MEMORY_CHOICE
  OPTIMIZE_MEMORY_CHOICE=${OPTIMIZE_MEMORY_CHOICE:-y}
  if [[ "${OPTIMIZE_MEMORY_CHOICE}" =~ ^[Yy]$ ]]; then
    echo -e "${INFO} 开始内存优化..."
    SERVICES=(
      postfix.service
      pve-ha-lrm.service
      pve-ha-crm.service
      spiceproxy.service
      pve-firewall.service
      pvefw-logger.service
      pvescheduler.service
    )
    for svc in "${SERVICES[@]}"; do
      systemctl stop "${svc}" >/dev/null 2>&1 || true
      systemctl disable "${svc}" >/dev/null 2>&1 || true
      echo -e "${STEPS} 已停用并禁用：\033[95m${svc}\033[0m"
    done
    echo -e "${STEPS} 添加延启脚本：\033[95m/usr/sbin/pve-optimize.sh\033[0m"
    cat <<'EOF' > /usr/sbin/pve-optimize.sh
#!/bin/bash
SERVICES=(
  pve-ha-lrm.service
  pve-ha-crm.service
  spiceproxy.service
  pve-firewall.service
  pvefw-logger.service
  pvescheduler.service
)
for svc in "${SERVICES[@]}"; do
  systemctl stop "${svc}" >/dev/null 2>&1 || true
done
echo "All down!!!"
EOF
    chmod +x /usr/sbin/pve-optimize.sh
    if [[ -f /etc/rc.local ]]; then
      grep -q '/usr/sbin/pve-optimize.sh' /etc/rc.local || \
      sed -i '/^exit 0/i sleep 300 \&\& /usr/sbin/pve-optimize.sh' /etc/rc.local
    else
      echo -e "${INFO} /etc/rc.local 不存在，跳过插入命令！"
    fi
    FILES=(
      /usr/share/perl5/PVE/Service/pveproxy.pm
      /usr/share/perl5/PVE/Service/pvedaemon.pm
      /usr/share/perl5/PVE/Service/spiceproxy.pm
    )
    for file in "${FILES[@]}"; do
      if [[ -f "${file}" ]] && grep -q 'max_workers\s*=>\s*3' "${file}"; then
        sed -i 's|max_workers\s*=>\s*3|max_workers => 1|' "${file}"
        echo -e "${STEPS} 已修改：\033[95m${file}\033[0m"
      else
        echo -e "${STEPS} 已跳过：\033[95m${file}\033[0m"
      fi
    done
    echo -e "${SUCCESS} 内存优化完成！"
  else
    echo -e "${INFO} 已跳过内存优化！"
  fi
}

create_vmbr0() {
  read -p "$(echo -e "${OPTIONS} 是否创建网桥？[\033[92mY\033[0m/n]：")" CREATE_BRIDGE_CHOICE
  CREATE_BRIDGE_CHOICE=${CREATE_BRIDGE_CHOICE:-y}
  if [[ "${CREATE_BRIDGE_CHOICE}" =~ ^[Yy]$ ]]; then
    echo -e "${STEPS} 配置 \033[95m/etc/network/interfaces\033[0m"
    cat <<EOF > /etc/network/interfaces
auto lo
iface lo inet loopback

iface ${NET_IF} inet manual
    hwaddress ether ${MAC_ADDR}

auto vmbr0
iface vmbr0 inet static
    address ${IP_ADDR}
    gateway ${GATEWAY}
    netmask ${NETMASK_DECIMAL}
    bridge-ports ${NET_IF}
    bridge-stp off
    bridge-fd 0
EOF
    if [[ "${VERSION_CODENAME}" == "trixie" ]]; then
      grep -qxF "source /etc/network/interfaces.d/sdn" /etc/network/interfaces || sed -i '1i source /etc/network/interfaces.d/sdn' /etc/network/interfaces
    fi
    echo -e "${SUCCESS} 网桥 vmbr0 配置已写入！"
    configure_ipv6_sysctl
  else
    echo -e "${INFO} 已跳过网桥创建！"
  fi
}

configure_ipv6_sysctl() {
  echo -e "${INFO} 开始配置 IPv6 参数..."
  add_or_update_sysctl_param() {
    local KEY=${1}
    local VALUE=${2}
    if grep -qE "^${KEY}=" /etc/sysctl.conf; then
      sed -i "s|^${KEY}=.*|${KEY}=${VALUE}|" /etc/sysctl.conf
      echo -e "${STEPS} 更新参数：\033[95m${KEY}=${VALUE}\033[0m"
    else
      echo "${KEY}=${VALUE}" >> /etc/sysctl.conf
      echo -e "${STEPS} 添加参数：\033[95m${KEY}=${VALUE}\033[0m"
    fi
  }
  add_or_update_sysctl_param "net.ipv6.conf.all.accept_ra" 2
  add_or_update_sysctl_param "net.ipv6.conf.default.accept_ra" 2
  add_or_update_sysctl_param "net.ipv6.conf.vmbr0.accept_ra" 2
  add_or_update_sysctl_param "net.ipv6.conf.all.autoconf" 1
  add_or_update_sysctl_param "net.ipv6.conf.default.autoconf" 1
  add_or_update_sysctl_param "net.ipv6.conf.vmbr0.autoconf" 1
  echo -e "${SUCCESS} IPv6 参数配置成功！"
}

prompt_reboot() {
  read -p "$(echo -e "${OPTIONS} 是否立即重启？[\033[92mY\033[0m/n]：")" REBOOT_CHOICE
  REBOOT_CHOICE=${REBOOT_CHOICE:-y}
  if [[ "${REBOOT_CHOICE}" =~ ^[Yy]$ ]]; then
    for ((i=5; i>=0; i--)); do
      echo -ne "${STEPS} 倒计时：[ "
      for ((j=5; j>i; j--)); do echo -ne "\e[31m=\e[0m"; done
      for ((j=i; j>0; j--)); do echo -ne "\e[32m-\e[0m"; done
      echo -ne " ]\r"
      sleep 1
    done
    echo -e "\n${INFO} 重启中..."
    reboot
  else
    echo -e "${INFO} 请手动重启！"
  fi
  exit 0
}

# ========== 主流程 ==========
check_env
check_select_interface
detect_network_info
confirm_source
backup_and_comment_sources
setup_repositories
setup_networking
set_hostname
configure_network
install_pve
optimize_memory
create_vmbr0
prompt_reboot
